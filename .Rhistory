sequencing.type="single-cell",
cnv.scale=3, loh.scale=3,expr.cutoff=0.1,matrix.type="normalized", filter="median",
annotation=annotation, method="iterative", loh=loh,
control.sample.ids="REF", cytoband=cytoband)
vals = data[, colnames(data) %in% "REF", drop=F]
vals[1,]
mean_ref_vals = mean(vals)
mean_ref_sd <- mean(apply(vals, 2, function(x) sd(x, na.rm = T))) * 1.5
upper_bound = mean_ref_vals + mean_ref_sd
lower_bound = mean_ref_vals - mean_ref_sd
mean_ref_vals
vals
mean(vals)
mean(vals, na.rm=T)
ls(vals)
str(vals)
as.mateix(  vals = data[, colnames(data) %in% object@control.sample.ids)
vals = data[, colnames(data) %in% object@control.sample.ids]
vals
vals = data[, colnames(data) %in% "REF"]
va;s
vals
mean(vals)
mean_ref_vals = mean(vals)
mean_ref_sd <- mean(apply(vals, 2, function(x) sd(x, na.rm = T))) * 1.5
upper_bound = mean_ref_vals + mean_ref_sd
lower_bound = mean_ref_vals - mean_ref_sd
as.matrix(vals)
mean_ref_sd <- mean(apply(as.matrix(vals), 2, function(x) sd(x, na.rm = T))) * 1.5
mean_ref_sd
vals = data[, 1:4]
mean_ref_vals = mean(vals)
mean_ref_sd <- mean(apply(as.matrix(vals), 2, function(x) sd(x, na.rm = T))) * 1.5
vals
vals[1,]
vals = data[, 1:4]
mean_ref_vals = mean(vals)
mean_ref_sd <- mean(apply(as.matrix(vals), 2, function(x) sd(x, na.rm = T))) * 1.5
mean(vals)
mean(vals, na.rm=T)
mean(as.matrix(vals), na.rm=T)
vals = data[, colnames(data) %in% object@control.sample.ids]
mean_ref_vals = mean(as.matrix(vals), na.rm=T)
mean_ref_sd <- mean(apply(as.matrix(vals), 2, function(x) sd(x, na.rm = T))) * 1.5
upper_bound = mean_ref_vals + mean_ref_sd
lower_bound = mean_ref_vals - mean_ref_sd
vals
ControlNormalize <- function(object) {
object@control.normalized <- list()
object@control.normalized.noiseRemoved <- list()
for (i in 1:object@cnv.scale) {
object@control.normalized[[i]] <- AverageReference(data = object@center.smoothed.data[[i]], ref_ids = object@control.sample.ids)
data <- 2^object@control.normalized[[i]]
lower_bound <- mean(apply(data, 2,
function(x) quantile(x, na.rm=TRUE)[[1]]))
upper_bound <- mean(apply(data, 2,
function(x) quantile(x, na.rm=TRUE)[[5]]))
# apply bounds
data[data < lower_bound] <- lower_bound
data[data > upper_bound] <- upper_bound
vals = data[, colnames(data) %in% object@control.sample.ids]
mean_ref_vals = mean(as.matrix(vals), na.rm=T)
mean_ref_sd <- mean(apply(as.matrix(vals), 2, function(x) sd(x, na.rm = T))) * 1.5
upper_bound = mean_ref_vals + mean_ref_sd
lower_bound = mean_ref_vals - mean_ref_sd
data[data > lower_bound & data <
data] = mean_ref_vals
object@control.normalized.noiseRemoved[[i]] <- data
}
return(object)
}
object <- CreateCasperObject(raw.data=data,loh.name.mapping=loh.name.mapping,
sequencing.type="single-cell",
cnv.scale=3, loh.scale=3,expr.cutoff=0.1,matrix.type="normalized", filter="median",
annotation=annotation, method="iterative", loh=loh,
control.sample.ids="REF", cytoband=cytoband)
object.raw.data <- data
gene.average <- rowMeans(((2^object.raw.data) - 1))
expr.cutoff
expr.cutoff <- 0.1
indices <- which(gene.average < expr.cutoff)
if(length(indices) >0) {
object@data <- object.raw.data[-1 * indices, , drop=FALSE]
object.data <- object@data
object@annotation.filt <- object@annotation[-1 * indices, , drop=FALSE]
} else {
object@data <- object.raw.data
object.data <- object@data
object@annotation.filt <- object@annotation
}
centered.data <-  t(apply(t(object.data), 2, function(y) (y - mean(y)) / sd(y) ^ as.logical(sd(y))))
object@centered.data <- AverageReference(data = centered.data, ref_ids = object@control.sample.ids)
lower_bound <- mean(apply(object@centered.data, 2,
function(x) quantile(x, na.rm=TRUE)[[1]]))
upper_bound <- mean(apply(object@centered.data, 2,
function(x) quantile(x, na.rm=TRUE)[[5]]))
threshold = mean(abs(c(lower_bound, upper_bound)))
object@centered.data[object@centered.data > threshold] <- threshold
object@centered.data[object@centered.data < (-1 * threshold)] <- -1 * threshold
object <- ProcessData(object)
CreateCasperObject <- function(raw.data, annotation, control.sample.ids, cytoband, loh.name.mapping, cnv.scale, loh.scale,
method, loh, project = "casperProject", matrix.type="raw", sequencing.type, expr.cutoff = 0.1, log.transformed = TRUE,
window.length = 50, length.iterations = 50,  genomeVersion = "hg19", filter= "median",
...) {
object <- new(Class = "casper", raw.data = raw.data, loh = loh, annotation = annotation, sequencing.type = sequencing.type,
control.sample.ids = control.sample.ids, project.name = project,  cytoband = cytoband, loh.name.mapping = loh.name.mapping,
cnv.scale = cnv.scale, loh.scale = loh.scale, matrix.type = matrix.type, method = method, window.length = window.length, length.iterations = length.iterations,
genomeVersion = genomeVersion, filter = filter)
object.raw.data <- object@raw.data
if(matrix.type == "normalized") {
gene.average <- rowMeans(((2^object.raw.data) - 1))
}
if(matrix.type == "raw") {
gene.average <- rowMeans(object.raw.data)
}
indices <- which(gene.average < expr.cutoff)
if(length(indices) >0) {
object@data <- object.raw.data[-1 * indices, , drop=FALSE]
object.data <- object@data
object@annotation.filt <- object@annotation[-1 * indices, , drop=FALSE]
} else {
object@data <- object.raw.data
object.data <- object@data
object@annotation.filt <- object@annotation
}
if(is.null( object.data) || nrow( object.data) < 1 || ncol( object.data) < 1){  stop("Error, data has no rows or columns") }
if(matrix.type == "raw") {
cs <- colSums(object.data)
object.data <- sweep(object.data, STATS=cs, MARGIN=2, FUN="/")
normalize_factor <-  median(cs)
object.data  <- object.data * normalize_factor
object.data <- log2(object.data + 1)
#centered.data <-  t(scale(t(object.data)))
}
centered.data <-  t(apply(t(object.data), 2, function(y) (y - mean(y)) / sd(y) ^ as.logical(sd(y))))
object@centered.data <- AverageReference(data = centered.data, ref_ids = object@control.sample.ids)
lower_bound <- mean(apply(object@centered.data, 2,
function(x) quantile(x, na.rm=TRUE)[[1]]))
upper_bound <- mean(apply(object@centered.data, 2,
function(x) quantile(x, na.rm=TRUE)[[5]]))
threshold = mean(abs(c(lower_bound, upper_bound)))
object@centered.data[object@centered.data > threshold] <- threshold
object@centered.data[object@centered.data < (-1 * threshold)] <- -1 * threshold
#  object <- ProcessData(object)
return(object)
}
object <- CreateCasperObject(raw.data=data,loh.name.mapping=loh.name.mapping,
sequencing.type="single-cell",
cnv.scale=3, loh.scale=3,expr.cutoff=0.1,matrix.type="normalized", filter="median",
annotation=annotation, method="iterative", loh=loh,
control.sample.ids="REF", cytoband=cytoband)
object <- PerformMedianFilterByChr(object)
warnings()
object <- CenterSmooth(object)
object <- ControlNormalize(object)
object <- CreateCasperObject(raw.data=data,loh.name.mapping=loh.name.mapping,
sequencing.type="single-cell",
cnv.scale=3, loh.scale=3,expr.cutoff=0.1,matrix.type="normalized", filter="median",
annotation=annotation, method="iterative", loh=loh,
control.sample.ids="REF", cytoband=cytoband)
#'
CreateCasperObject <- function(raw.data, annotation, control.sample.ids, cytoband, loh.name.mapping, cnv.scale, loh.scale,
method, loh, project = "casperProject", matrix.type="raw", sequencing.type, expr.cutoff = 0.1, log.transformed = TRUE,
window.length = 50, length.iterations = 50,  genomeVersion = "hg19", filter= "median",
...) {
object <- new(Class = "casper", raw.data = raw.data, loh = loh, annotation = annotation, sequencing.type = sequencing.type,
control.sample.ids = control.sample.ids, project.name = project,  cytoband = cytoband, loh.name.mapping = loh.name.mapping,
cnv.scale = cnv.scale, loh.scale = loh.scale, matrix.type = matrix.type, method = method, window.length = window.length, length.iterations = length.iterations,
genomeVersion = genomeVersion, filter = filter)
object.raw.data <- object@raw.data
if(matrix.type == "normalized") {
gene.average <- rowMeans(((2^object.raw.data) - 1))
}
if(matrix.type == "raw") {
gene.average <- rowMeans(object.raw.data)
}
indices <- which(gene.average < expr.cutoff)
if(length(indices) >0) {
object@data <- object.raw.data[-1 * indices, , drop=FALSE]
object.data <- object@data
object@annotation.filt <- object@annotation[-1 * indices, , drop=FALSE]
} else {
object@data <- object.raw.data
object.data <- object@data
object@annotation.filt <- object@annotation
}
if(is.null( object.data) || nrow( object.data) < 1 || ncol( object.data) < 1){  stop("Error, data has no rows or columns") }
if(matrix.type == "raw") {
cs <- colSums(object.data)
object.data <- sweep(object.data, STATS=cs, MARGIN=2, FUN="/")
normalize_factor <-  median(cs)
object.data  <- object.data * normalize_factor
object.data <- log2(object.data + 1)
#centered.data <-  t(scale(t(object.data)))
}
centered.data <-  t(apply(t(object.data), 2, function(y) (y - mean(y)) / sd(y) ^ as.logical(sd(y))))
object@centered.data <- AverageReference(data = centered.data, ref_ids = object@control.sample.ids)
lower_bound <- mean(apply(object@centered.data, 2,
function(x) quantile(x, na.rm=TRUE)[[1]]))
upper_bound <- mean(apply(object@centered.data, 2,
function(x) quantile(x, na.rm=TRUE)[[5]]))
threshold = mean(abs(c(lower_bound, upper_bound)))
object@centered.data[object@centered.data > threshold] <- threshold
object@centered.data[object@centered.data < (-1 * threshold)] <- -1 * threshold
object <- ProcessData(object)
return(object)
}
object <- CreateCasperObject(raw.data=data,loh.name.mapping=loh.name.mapping,
sequencing.type="single-cell",
cnv.scale=3, loh.scale=3,expr.cutoff=0.1,matrix.type="normalized", filter="median",
annotation=annotation, method="iterative", loh=loh,
control.sample.ids="REF", cytoband=cytoband)
CreateCasperObject <- function(raw.data, annotation, control.sample.ids, cytoband, loh.name.mapping, cnv.scale, loh.scale,
method, loh, project = "casperProject", matrix.type="raw", sequencing.type, expr.cutoff = 0.1, log.transformed = TRUE,
window.length = 50, length.iterations = 50,  genomeVersion = "hg19", filter= "median",
...) {
object <- new(Class = "casper", raw.data = raw.data, loh = loh, annotation = annotation, sequencing.type = sequencing.type,
control.sample.ids = control.sample.ids, project.name = project,  cytoband = cytoband, loh.name.mapping = loh.name.mapping,
cnv.scale = cnv.scale, loh.scale = loh.scale, matrix.type = matrix.type, method = method, window.length = window.length, length.iterations = length.iterations,
genomeVersion = genomeVersion, filter = filter)
object.raw.data <- object@raw.data
if(matrix.type == "normalized") {
gene.average <- rowMeans(((2^object.raw.data) - 1))
}
if(matrix.type == "raw") {
gene.average <- rowMeans(object.raw.data)
}
indices <- which(gene.average < expr.cutoff)
if(length(indices) >0) {
object@data <- object.raw.data[-1 * indices, , drop=FALSE]
object.data <- object@data
object@annotation.filt <- object@annotation[-1 * indices, , drop=FALSE]
} else {
object@data <- object.raw.data
object.data <- object@data
object@annotation.filt <- object@annotation
}
if(is.null( object.data) || nrow( object.data) < 1 || ncol( object.data) < 1){  stop("Error, data has no rows or columns") }
if(matrix.type == "raw") {
cs <- colSums(object.data)
object.data <- sweep(object.data, STATS=cs, MARGIN=2, FUN="/")
normalize_factor <-  median(cs)
object.data  <- object.data * normalize_factor
object.data <- log2(object.data + 1)
#centered.data <-  t(scale(t(object.data)))
}
centered.data <-  t(apply(t(object.data), 2, function(y) (y - mean(y)) / sd(y) ^ as.logical(sd(y))))
object@centered.data <- AverageReference(data = centered.data, ref_ids = object@control.sample.ids)
lower_bound <- mean(apply(object@centered.data, 2,
function(x) quantile(x, na.rm=TRUE)[[1]]))
upper_bound <- mean(apply(object@centered.data, 2,
function(x) quantile(x, na.rm=TRUE)[[5]]))
threshold = mean(abs(c(lower_bound, upper_bound)))
object@centered.data[object@centered.data > threshold] <- threshold
object@centered.data[object@centered.data < (-1 * threshold)] <- -1 * threshold
# object <- ProcessData(object)
return(object)
}
object <- CreateCasperObject(raw.data=data,loh.name.mapping=loh.name.mapping,
sequencing.type="single-cell",
cnv.scale=3, loh.scale=3,expr.cutoff=0.1,matrix.type="normalized", filter="median",
annotation=annotation, method="iterative", loh=loh,
control.sample.ids="REF", cytoband=cytoband)
object <- ProcessData(object)
if (object@filter=="median")   object <- PerformMedianFilterByChr(object)
if (object@filter=="mean")   object <- PerformMeanFilterByChr(object)
object <- CenterSmooth(object)
object <- ControlNormalize(object)
CenterSmooth
ControlNormalize
#' @title CreateCasperObject
#'
#' @param raw.data  the matrix of genes (rows) vs. cells (columns) containing the raw counts
#'
#' @param annotation data.frame containing positions of each gene along each chromosome in the genome
#'
#' @param control.sample.ids  vector containing the  reference (normal) cell (sample) names
#'
#' @param cytoband cytoband information downloaded from UCSC hg19: http://hgdownload.cse.ucsc.edu/goldenpath/hg19/database/cytoBand.txt.gz hg38:http://hgdownload.cse.ucsc.edu/goldenpath/hg38/database/cytoBand.txt.gz
#'
#' @param loh.name.mapping  contains the cell (sample) name and the matching baf signal sample name
#'
#' @param cnv.scale  maximum expression scale
#'
#' @param loh.scale  maximum baf scale
#'
#' @param method analysis type: itereative  or fixed (default: iterative)
#'
#' @param loh The original baf signal
#'
#' @param sequencing.type sequencing.type sequencing type: bulk or single-cell
#'
#' @param expr.cutoff expression cutoff for lowly expressed genes
#'
#' @param log.transformed indicates if the data log2 transformed or not. (default:TRUE)
#'
#' @param window.length window length used for median filtering (default: 50)
#'
#' @param length.iterations increase in window length at each scale iteration (default: 50)
#'
#' @param vis.bound threshold for control normalized data for better visualization (default: 2)
#'
#' @param genomeVersion genomeVersion: hg19 or hg38 (default: hg19)
#'
#' @description Creation of a casper object.
#'
#' @return casper
#'
#' @export
#'
CreateCasperObject <- function(raw.data, annotation, control.sample.ids, cytoband, loh.name.mapping, cnv.scale, loh.scale,
method, loh, project = "casperProject", matrix.type="raw", sequencing.type, expr.cutoff = 0.1, log.transformed = TRUE,
window.length = 50, length.iterations = 50,  genomeVersion = "hg19", filter= "median",
...) {
object <- new(Class = "casper", raw.data = raw.data, loh = loh, annotation = annotation, sequencing.type = sequencing.type,
control.sample.ids = control.sample.ids, project.name = project,  cytoband = cytoband, loh.name.mapping = loh.name.mapping,
cnv.scale = cnv.scale, loh.scale = loh.scale, matrix.type = matrix.type, method = method, window.length = window.length, length.iterations = length.iterations,
genomeVersion = genomeVersion, filter = filter)
object.raw.data <- object@raw.data
if(matrix.type == "normalized") {
gene.average <- rowMeans(((2^object.raw.data) - 1))
}
if(matrix.type == "raw") {
gene.average <- rowMeans(object.raw.data)
}
indices <- which(gene.average < expr.cutoff)
if(length(indices) >0) {
object@data <- object.raw.data[-1 * indices, , drop=FALSE]
object.data <- object@data
object@annotation.filt <- object@annotation[-1 * indices, , drop=FALSE]
} else {
object@data <- object.raw.data
object.data <- object@data
object@annotation.filt <- object@annotation
}
if(is.null( object.data) || nrow( object.data) < 1 || ncol( object.data) < 1){  stop("Error, data has no rows or columns") }
if(matrix.type == "raw") {
cs <- colSums(object.data)
object.data <- sweep(object.data, STATS=cs, MARGIN=2, FUN="/")
normalize_factor <-  median(cs)
object.data  <- object.data * normalize_factor
object.data <- log2(object.data + 1)
#centered.data <-  t(scale(t(object.data)))
}
centered.data <-  t(apply(t(object.data), 2, function(y) (y - mean(y)) / sd(y) ^ as.logical(sd(y))))
object@centered.data <- AverageReference(data = centered.data, ref_ids = object@control.sample.ids)
lower_bound <- mean(apply(object@centered.data, 2,
function(x) quantile(x, na.rm=TRUE)[[1]]))
upper_bound <- mean(apply(object@centered.data, 2,
function(x) quantile(x, na.rm=TRUE)[[5]]))
threshold = mean(abs(c(lower_bound, upper_bound)))
object@centered.data[object@centered.data > threshold] <- threshold
object@centered.data[object@centered.data < (-1 * threshold)] <- -1 * threshold
object <- ProcessData(object)
return(object)
}
#' @title ProcessData()
#'
#' @description Processing expression signal. Step 1. Recursively iterative median filtering  Step 2. Center Normalization Step 3. Control Normalization
#'
#' @param object casper object
#'
#' @return object
#'
#' @export
#'
#'
ProcessData <- function(object) {
if (object@filter=="median")   object <- PerformMedianFilterByChr(object)
if (object@filter=="mean")   object <- PerformMeanFilterByChr(object)
object <- CenterSmooth(object)
#object <- ControlNormalize(object)
return(object)
}
object <- CreateCasperObject(raw.data=data,loh.name.mapping=loh.name.mapping,
sequencing.type="single-cell",
cnv.scale=3, loh.scale=3,expr.cutoff=0.1,matrix.type="normalized", filter="median",
annotation=annotation, method="iterative", loh=loh,
control.sample.ids="REF", cytoband=cytoband)
object <- ControlNormalize(object)
ProcessData <- function(object) {
if (object@filter=="median")   object <- PerformMedianFilterByChr(object)
if (object@filter=="mean")   object <- PerformMeanFilterByChr(object)
object <- CenterSmooth(object)
object <- ControlNormalize(object)
return(object)
}
object <- CreateCasperObject(raw.data=data,loh.name.mapping=loh.name.mapping,
sequencing.type="single-cell",
cnv.scale=3, loh.scale=3,expr.cutoff=0.1,matrix.type="normalized", filter="median",
annotation=annotation, method="iterative", loh=loh,
control.sample.ids="REF", cytoband=cytoband)
## plot median filtered gene expression matrix
plotHeatmap(object, fileName="heatmap.png", cnv.scale= 3, cluster_cols = F, cluster_rows = T, show_rownames = T, only_soi = T)
object <- CreateCasperObject(raw.data=data,loh.name.mapping=loh.name.mapping,
sequencing.type="single-cell",
cnv.scale=3, loh.scale=3,expr.cutoff=0.1,matrix.type="normalized", filter="mean",
annotation=annotation, method="iterative", loh=loh,
control.sample.ids="REF", cytoband=cytoband)
## plot median filtered gene expression matrix
plotHeatmap(object, fileName="heatmapMean.png", cnv.scale= 3, cluster_cols = F, cluster_rows = T, show_rownames = T, only_soi = T)
plotHeatmap
plotHeatmapobject <- CreateCasperObject(raw.data=data,loh.name.mapping=loh.name.mapping,
sequencing.type="single-cell",
cnv.scale=3, loh.scale=3,expr.cutoff=0.1,matrix.type="normalized", filter="median",
annotation=annotation, method="iterative", loh=loh,
control.sample.ids="REF", cytoband=cytoband)
object <- CreateCasperObject(raw.data=data,loh.name.mapping=loh.name.mapping,
sequencing.type="single-cell",
cnv.scale=3, loh.scale=3,expr.cutoff=0.1,matrix.type="normalized", filter="median",
annotation=annotation, method="iterative", loh=loh,
control.sample.ids="REF", cytoband=cytoband)
## plot median filtered gene expression matrix
plotHeatmap(object, fileName="heatmapMean.png", cnv.scale= 3, cluster_cols = F, cluster_rows = T, show_rownames = T, only_soi = T)
library(Seurat)
library(CaSpER)
data("hg19_cytoband")
# expression data is downloaded from https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE110499
counts  <- read.delim("GSE110499_GEO_processed_MM_10X_raw_UMI_count_martix.txt", stringsAsFactor=F, header=T)
rownames(counts) <- counts[, 1]
counts <- counts[, -1]
mm135 <- CreateSeuratObject(counts = counts, project = "mm135", min.cells = 3, min.features = 200)
mm135[["percent.mt"]] <- PercentageFeatureSet(mm135, pattern = "^MT-")
mm135 <- subset(mm135, subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mt < 5)
mm135 <- NormalizeData(mm135 , scale.factor = 1e6, normalization.method = "RC")
mm135 <- FindVariableFeatures(mm135, do.plot = T, nfeatures = 1000)
mm135 <- ScaleData(mm135)
mm135 <- RunPCA(mm135, features = VariableFeatures(object = mm135),npcs = 100)
mm135 <- RunTSNE(mm135, dims.use = 1:10)
DimPlot(pbmc, reduction = "tsne")
FeaturePlot(pbmc, features = c("SDC1", "CD38"))
mm135 <- FindNeighbors(mm135, dims = 1:10)
mm135 <- FindClusters(mm135, resolution = 0.5)
DimPlot(pbmc, reduction = "tsne", label=T)
log.ge <- as.matrix(mm135@assays$RNA@data)
control <- names(Idents(mm135) )[Idents(mm135) %in% c(2,7)]
mm <- names(Idents(mm135) )[Idents(mm135) %in% c(0, 1, 3, 4)]
genes <- rownames(log.ge)
annotation <- generateAnnotation(id_type="hgnc_symbol", genes=genes, centromere=centromere, ishg19 = T)
log.ge <- log.ge[match( annotation$Gene,rownames(log.ge)) , ]
rownames(log.ge) <- annotation$Gene
log.ge <- log2(log.ge +1)
load("maf.rda") ## from https://github.com/akdess/CaSpER/blob/master/data/maf.rda
loh<- list()
loh[[1]] <- maf
names(loh) <- "MM135"
loh.name.mapping <- data.frame (loh.name= "MM135" , sample.name=colnames(log.ge))
object <- CreateCasperObject(raw.data=log.ge,loh.name.mapping=loh.name.mapping, sequencing.type="single-cell",
cnv.scale=3, loh.scale=3,
expr.cutoff=0.1, filter="median", matrix.type="normalized",
annotation=annotation, method="iterative", loh=loh,
control.sample.ids=control, cytoband=cytoband)
counts  <- read.delim("GSE110499_GEO_processed_MM_10X_raw_UMI_count_matrix.txt", stringsAsFactor=F, header=T)
rownames(counts) <- counts[, 1]
counts <- counts[, -1]
mm135 <- CreateSeuratObject(counts = counts, project = "mm135", min.cells = 3, min.features = 200)
mm135[["percent.mt"]] <- PercentageFeatureSet(mm135, pattern = "^MT-")
mm135 <- subset(mm135, subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mt < 5)
mm135 <- NormalizeData(mm135 , scale.factor = 1e6, normalization.method = "RC")
mm135 <- FindVariableFeatures(mm135, do.plot = T, nfeatures = 1000)
mm135 <- ScaleData(mm135)
mm135 <- RunPCA(mm135, features = VariableFeatures(object = mm135),npcs = 100)
mm135 <- RunTSNE(mm135, dims.use = 1:10)
DimPlot(pbmc, reduction = "tsne")
FeaturePlot(pbmc, features = c("SDC1", "CD38"))
mm135 <- FindNeighbors(mm135, dims = 1:10)
mm135 <- FindClusters(mm135, resolution = 0.5)
DimPlot(pbmc, reduction = "tsne", label=T)
log.ge <- as.matrix(mm135@assays$RNA@data)
control <- names(Idents(mm135) )[Idents(mm135) %in% c(2,7)]
mm <- names(Idents(mm135) )[Idents(mm135) %in% c(0, 1, 3, 4)]
genes <- rownames(log.ge)
annotation <- generateAnnotation(id_type="hgnc_symbol", genes=genes, centromere=centromere, ishg19 = T)
log.ge <- log.ge[match( annotation$Gene,rownames(log.ge)) , ]
rownames(log.ge) <- annotation$Gene
log.ge <- log2(log.ge +1)
library(Seurat)
library(CaSpER)
data("hg19_cytoband")
# expression data is downloaded from https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE110499
counts  <- read.delim("GSE110499_GEO_processed_MM_10X_raw_UMI_count_matrix.txt", stringsAsFactor=F, header=T)
rownames(counts) <- counts[, 1]
counts <- counts[, -1]
mm135 <- CreateSeuratObject(counts = counts, project = "mm135", min.cells = 3, min.features = 200)
mm135[["percent.mt"]] <- PercentageFeatureSet(mm135, pattern = "^MT-")
mm135 <- subset(mm135, subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mt < 5)
mm135 <- NormalizeData(mm135 , scale.factor = 1e6, normalization.method = "RC")
mm135 <- FindVariableFeatures(mm135, do.plot = T, nfeatures = 1000)
mm135 <- ScaleData(mm135)
mm135 <- RunPCA(mm135, features = VariableFeatures(object = mm135),npcs = 100)
mm135 <- RunTSNE(mm135, dims.use = 1:10)
DimPlot(pbmc, reduction = "tsne")
FeaturePlot(pbmc, features = c("SDC1", "CD38"))
mm135 <- FindNeighbors(mm135, dims = 1:10)
mm135 <- FindClusters(mm135, resolution = 0.5)
DimPlot(pbmc, reduction = "tsne", label=T)
log.ge <- as.matrix(mm135@assays$RNA@data)
control <- names(Idents(mm135) )[Idents(mm135) %in% c(2,7)]
mm <- names(Idents(mm135) )[Idents(mm135) %in% c(0, 1, 3, 4)]
Sys.getenv("PATH")
require(devtools)
install_github("akdess/CaSpER")
require(devtools)
install_github("akdess/CaSpER")
require(devtools)
install_github("akdess/CaSpER", force=T)
require(devtools)
install_github("akdess/CaSpER", force=T)
?install_github
require(devtools)
install_github("akdess/CaSpER", force=TRUE
)
